<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><link rel=icon type=image/svg+xml href=/favicon.svg sizes=any><style type=text/css>body{font-family:monospace}</style><title>JVM Memory Settings in a Container Environment</title><meta name=description content="My Personal Space - IT, Development, Software Architecture and Things I Care About"><meta name=author content="@atamanroman - Roman Ataman"><meta name=keywords content="IT Development Software-Architecture Java Docker"><link rel=stylesheet href=/css/style.css></head><body><header><div id=logo><a href=https://www.atamanroman.dev/>atamanroman.dev</a></div><div></div><p><nav><a href=/><b>Start</b></a>
· <a href=/tags/><b>Tags</b></a></nav></p></header><main><article><h1>JVM Memory Settings in a Container Environment</h1><b><time>2018-11-10</time></b>
<a href=/tags/java>java</a>
<a href=/tags/jvm>jvm</a>
<a href=/tags/docker>docker</a><div><h2 id=tldr-the-bare-minimum-you-should-know-before-going-live>TL;DR: The Bare Minimum You Should Know Before Going Live</h2><p>Java memory management and configuration is still complex. Although the JVM can read cgroup memory limits and adapt memory usage accordingly since Java 9/8u131, it&rsquo;s not a golden bullet. You need to know what <code>-XX:+UseCGroupMemoryLimitForHeap</code> does and you need to fine tune some parameters for every deployment. Otherwise you risk wasting resources and money or getting your containers killed at the worst time possible. <code>-XX:MaxRAMFraction=1</code> is especially dangerous. Java 10+ brings a lot of improvements but still needs manual configuration. To be safe, load test your stuff.</p><hr><h2 id=update-things-have-changed-for-java-8u191-and-101112>UPDATE: Things Have Changed for Java 8u191+ and 10/11/12+</h2><p>A lot has changed since Java 8u191 and things should work out of the box. So this article is partly out-of-date. We&rsquo;re keeping it online as a reference but please see our follow-up article <a href=https://www.atamanroman.dev/articles/usecontainersupport-to-the-rescue/><em>+UseContainerSupport to the Rescue</em></a> for more details.</p><hr><h2 id=about-us>About us</h2><p><a href=https://github.com/jkroepke>Joe</a> and <a href=https://twitter.com/atamanroman>I</a> both do a lot of work with Java on OpenShift/Kubernetes. Joe has a very strong operations background and I feel more at home with software development — yet we often do similar stuff. We also like to <del>argue</del> work together and this article is the result of one particularly interesting discussion about the JVM setting <code>+UseCGroupMemoryLimit</code>. We stitched this article together during a few Fridays at the office at <a href=https://adorsys.de>adorsys</a>.</p><h2 id=java-heap-sizing-basics>Java Heap Sizing Basics</h2><p>Per default the JVM automatically configures heap size according to the spec of the machine it is running on. On my brand new MacBook Pro 2018 this yields the following heap size:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sh data-lang=sh>$ java -XX:+PrintFlagsFinal -version <span class=p>|</span> grep -Ei <span class=s2>&#34;maxheapsize|maxram&#34;</span>
    uintx <span class=nv>DefaultMaxRAMFraction</span>   <span class=o>=</span> <span class=m>4</span>             <span class=o>{</span>product<span class=o>}</span>
    uintx MaxHeapSize             :<span class=o>=</span> <span class=m>8589934592</span>   <span class=o>{</span>product<span class=o>}</span>
    uint64_t <span class=nv>MaxRAM</span>               <span class=o>=</span> <span class=m>137438953472</span>  <span class=o>{</span>pd product<span class=o>}</span>
    uintx <span class=nv>MaxRAMFraction</span>          <span class=o>=</span> <span class=m>4</span>             <span class=o>{</span>product<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>As you can see, the JVM defaults to 8.0 GB max heap <code>(8589934592 / 1024^3)</code> and 0.5 GB initial heap on my machine. The formula behind this is straight forward. Using the JVM configuration parameter names, we end up with: <code>MaxHeapSize = MaxRAM * 1 / MaxRAMFraction</code> where MaxRAM is the available RAM<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and MaxRAMFraction is 4<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> by default. That means the <strong>JVM allocates up to 25% of your RAM per JVM</strong> running on your machine.</p><p>It&rsquo;s important to note that the JVM uses more memory than just heap. We can calculate the total memory usage roughly with <code>heap + stack per thread (XSS) * threads + constant overhead</code>.
The default for XSS depends on the OS and JVM and is somewhere between 256 KB and 1 MB<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. That means: every thread allocates at least 256 KB additional memory.
The constant overhead is all memory allocated by the JVM which is not heap or stack. This value depends on a lot of factors. See <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> and <code>-XX:NativeMemoryTracking</code><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> for more details.</p><p>You can change how the JVM does its memory management. The most common thing is to set <em>MaxHeap</em> (<code>-Xmx</code>) to a fixed, more or less carefully guessed value.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sh data-lang=sh>$ java -XX:+PrintFlagsFinal -Xmx1g -version <span class=p>|</span> grep -Ei <span class=s2>&#34;maxheapsize|maxram&#34;</span>

    uintx <span class=nv>DefaultMaxRAMFraction</span>   <span class=o>=</span> <span class=m>4</span>            <span class=o>{</span>product<span class=o>}</span>
    uintx MaxHeapSize             :<span class=o>=</span> <span class=m>1073741824</span>  <span class=o>{</span>product<span class=o>}</span>
    uint64_t <span class=nv>MaxRAM</span>               <span class=o>=</span> <span class=m>137438953472</span> <span class=o>{</span>pd product<span class=o>}</span>
    uintx <span class=nv>MaxRAMFraction</span>          <span class=o>=</span> <span class=m>4</span>            <span class=o>{</span>product<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>There are other ways to control the heap, too. We can adjust <code>MaxRAM</code>, effectively simulating a smaller machine.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sh data-lang=sh> $ java -XX:+PrintFlagsFinal -XX:MaxRAM<span class=o>=</span>1g -version <span class=p>|</span> grep -Ei <span class=s2>&#34;maxheapsize|maxram&#34;</span>
    uintx <span class=nv>DefaultMaxRAMFraction</span>   <span class=o>=</span> <span class=m>4</span>            <span class=o>{</span>product<span class=o>}</span>
    uintx MaxHeapSize             :<span class=o>=</span> <span class=m>268435456</span>   <span class=o>{</span>product<span class=o>}</span>
    uint64_t MaxRAM               :<span class=o>=</span> <span class=m>1073741824</span>  <span class=o>{</span>pd product<span class=o>}</span>
    uintx <span class=nv>MaxRAMFraction</span>          <span class=o>=</span> <span class=m>4</span>            <span class=o>{</span>product<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>Now the JVM is back in charge calculating the heap size, we just fine tune the parameters. In this case we end up with 256 MB max heap. That&rsquo;s fine for a desktop, but a bit conservative for a dedicated host. If we spend good money on a VPS with 1 GB RAM, we&rsquo;d like the JVM to make better use of the available resources. Here <code>-XX:MaxRAMFraction</code> comes into play. This parameter controls how much of the total RAM is up for grabs. <code>1/MaxRAMFraction</code> yields the percentage of RAM we can use. Since it only allows integer values > 0, there are only a few sensible configurations:</p><table><thead><tr><th style=text-align:center>MaxRAMFraction</th><th style=text-align:center>% of RAM for heap</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>100%</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>50%</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>33%</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>25%</td></tr></tbody></table><p>So for our dedicated 1 GB server it&rsquo;s enough to set <code>-XX:MaxRAMFraction=2</code> and we end up 512 MB max RAM.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sh data-lang=sh><span class=c1># -XX:MaxRAM is only set for the sake of this example to simulate a smaller physical machine</span>
$ java -XX:+PrintFlagsFinal -XX:MaxRAM<span class=o>=</span>1g -XX:MaxRAMFraction<span class=o>=</span><span class=m>2</span> -version <span class=p>|</span> grep -Ei <span class=s2>&#34;maxheapsize|maxram&#34;</span>
    uintx <span class=nv>DefaultMaxRAMFraction</span>   <span class=o>=</span> <span class=m>4</span>            <span class=o>{</span>product<span class=o>}</span>
    uintx MaxHeapSize             :<span class=o>=</span> <span class=m>536870912</span>   <span class=o>{</span>product<span class=o>}</span>
    uint64_t MaxRAM               :<span class=o>=</span> <span class=m>1073741824</span>  <span class=o>{</span>pd product<span class=o>}</span>
    uintx MaxRAMFraction          :<span class=o>=</span> <span class=m>2</span>           <span class=o>{</span>product<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>That looks pretty good for prod!</p><h2 id=java-heap-sizing-in-containers>Java Heap Sizing in Containers</h2><p>There are a lot of things you need to know to properly set up a JVM in a container. For instance, applications running in a Docker container always see the full resources available. It&rsquo;s not very intuitive, but cgroup<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> limits are not visible for the contained process. See for yourself<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sh data-lang=sh>$ docker run --rm alpine free -m
             total     used     free   shared  buffers   cached
Mem:          <span class=m>1998</span>     <span class=m>1565</span>      <span class=m>432</span>        <span class=m>0</span>        <span class=m>8</span>     <span class=m>1244</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sh data-lang=sh>$ docker run --rm -m 256m alpine free -m
             total     used     free   shared  buffers   cached
Mem:          <span class=m>1998</span>     <span class=m>1552</span>      <span class=m>445</span>        <span class=m>1</span>        <span class=m>8</span>     <span class=m>1244</span>
</code></pre></td></tr></table></div></div><p>That causes problems with the default JVM sizing. Because there are <em>a lot</em> of available resources visible on your expensive Kubernetes node it tries to hog a good amount of it. And this egoism makes sense when the JVM can own a good chunk of the underlying hardware (e.g. a dev workstation or a single purpose VM).</p><p>But it makes the JVM behave quite badly on container platforms per default. If the resources are shared between unrelated, more or less equally important processes, the optimistic resource allocation can cause problems. Depending on your current setup, one of two things can happen: a) the JVM is killed as soon as it tries to allocate more memory than it is allowed according to the quotas set in your deployment config or b) the JVM eats your precious resources for breakfast if there are no quotas.</p><p>So what&rsquo;s the fix? We <em>could</em> configure the JVM manually by setting <code>-Xmx</code> or <code>-XX:MaxRAM</code> accordingly. Or make the cgroup memory limits visible to it. And that&rsquo;s exactly what has already been done. The first cgroup related patches landed with Java 9 and were backported to Java 8u131<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> in April 2017<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>. Let&rsquo;s have a closer look.</p><p>To make the JVM play well with cgroup memory limits a new option <code>-XX:+UseCGroupMemoryLimitForHeap</code> was introduced. It sounds fancy but is pretty simple once you know the basics. It allows setting the heap to the cgroup memory limit. The JVM reads from <code>/sys/fs/cgroup/memory/memory.limit_in_bytes</code> and uses that value instead of <code>-XX:MaxRAM</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sh data-lang=sh>$ docker run --rm -m 1g openjdk:8-jdk cat /sys/fs/cgroup/memory/memory.limit_in_bytes
<span class=m>1073741824</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sh data-lang=sh>$ docker run --rm -m 1g openjdk:8-jdk sh -c <span class=s2>&#34;java -XX:+PrintFlagsFinal -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -version | grep -Ei &#39;maxheapsize|maxram&#39;&#34;</span>
    uintx <span class=nv>DefaultMaxRAMFraction</span>   <span class=o>=</span> <span class=m>4</span>             <span class=o>{</span>product<span class=o>}</span>
    uintx MaxHeapSize            :<span class=o>=</span> <span class=m>268435456</span>     <span class=o>{</span>product<span class=o>}</span>     <span class=c1># = 1073741824 / 4</span>
    uint64_t <span class=nv>MaxRAM</span>               <span class=o>=</span> <span class=m>137438953472</span>  <span class=o>{</span>pd product<span class=o>}</span>
    uintx <span class=nv>MaxRAMFraction</span>          <span class=o>=</span> <span class=m>4</span>             <span class=o>{</span>product<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>And that&rsquo;s it. 1 GB memory quota yields 256 MB heap. Exactly the same as in the non-docker examples. Note that <code>-XX:+UseCGroupMemoryLimitForHeap</code> requires <code>-XX:+UnlockExperimentalVMOptions</code> in order to work. And there&rsquo;s a good reason to it.</p><p>So the JVM is now aware of cgroup memory limits – you just need to enable that feature. Are we done here? We thought so at first. If you searched for <em>java container heap configuration prod</em> or something like that, almost every blog post was just advising you to set that flag and have a nice day. And we followed that advice – until we encountered some obviously broken behaviour. Containers limited to very small amounts of memory would almost instantly get <em>OOMKilled</em>. Which means the container tried to allocate more than 128 MB.
With everything we knew back then this should not happen. I mean the JVM <em>knew</em> there was only so much memory available. If anything, I&rsquo;d have expected an <code>OutOfMemoryError</code> if the heap was really too tight.
On the other hand, containers with larger memory limits were very inefficient. Using less than half of the 8 GB reserved memory per deployment wastes a lot of resources.</p><p>As it turns out using the cgroup memory limit instead of <code>-XX:MaxRAM</code> is not enough. Depending on the actual limit you can run into efficiency or stability issues. That&rsquo;s where people start tweaking with <code>-XX:MaxRAMFraction=1</code> so that the JVM can use all of the RAM for heap. But some basic load testing<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup> showed that&rsquo;s too much. As stated earlier, the JVM needs some memory per thread for its stack and some constant amount on top of it. Also there is often other stuff in a container which could possibly allocate additional memory (like SSHd, monitoring processes, the shell which spawned your process, &mldr;). And, last but not least, you <em>might</em> want to have enough free memory to be actually able to <code>docker exec</code> into your container to trigger a heap dump or attach a debugger. So you risk getting your container killed under load.</p><p>Getting <em>OOMKilled</em> is not a good thing. Your app can&rsquo;t react to in any way – it just gets killed. In my opinion, this should never happen. I always want to get an <code>OutOfMemoryError</code> when heap runs out so I can get a heap dump and analyse it. <em>OOMKilled</em> should only happen if there is something <em>really broken</em> like a memory leak in the JVM. That is necessary to protect other deployments on the same node.
If one instance of your service gets killed under heavy load it&rsquo;s more likely that other instances go down with them as well because the load gets rebalanced. This can snowball and kill your whole system, which otherwise might have worked pretty OK if the resources were set and limited properly. The worst thing is that this type of bug only occurs if your system is under stress. Not a good time to fail.</p><p>So <code>-XX:MaxRAMFraction=1</code> should be avoided in any case. That leaves us with 50% or less memory utilisation. I&rsquo;d say, that is not acceptable for most configurations. After some testing, we found out that most of our services required roughly 250 MB additional free RAM to be really safe. So the bigger the memory gets, the less useful becomes <code>-XX:+UseCGroupMemoryLimitForHeap</code>.</p><h2 id=better-ways-to-configure-heap>Better Ways to Configure Heap</h2><p>There are a few approaches to fix this. You could give up and just set <code>-Xmx</code>. Or set <code>-XX:MaXRAM</code> to a percentage of the real quota and use <code>-XX:MaxRAMFraction=1</code>. The <code>ENTRYPOINT</code> would be a good spot for that.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sh data-lang=sh><span class=c1># set -XX:MaxRAM to 70% of the cgroup limit</span>
docker run --rm -m 1g openjdk:8-jdk sh -c <span class=s1>&#39;exec java -XX:MaxRAM=$(( $(cat /sys/fs/cgroup/memory/memory.limit_in_bytes) * 70 / 100 )) -XX:+PrintFlagsFinal -version&#39;</span>
</code></pre></td></tr></table></div></div><p>The most elegant solution is to upgrade to Java 10+. Java 10 deprecates <code>-XX:+UseCGroupMemoryLimitForHeap</code><sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup> and introduces <code>-XX:+UseContainerSupport</code><sup id=fnref:12><a href=#fn:12 class=footnote-ref role=doc-noteref>12</a></sup>, which supersedes it. It also introduces <code>-XX:MaxRAMPercentage</code><sup id=fnref:13><a href=#fn:13 class=footnote-ref role=doc-noteref>13</a></sup> which takes a value between 0 and 100. This allows fine grained control of the amount of RAM the JVM is allowed to allocate.
Since <code>+UseContainerSupport</code> is enabled by default, everything should work out of the box. You may want to fine tune <code>-XX:MaxRAMPercentage</code> to be both <em>efficient and safe</em>, depending on your environment. But the new parameters default to a good compromise and are easier to understand. That&rsquo;s a huge step in the right direction.</p><h2 id=references>References</h2><h3 id=how-we-tested>How we Tested</h3><p>Tests were run with Azul JDK 8 and OpenJDK 10 on a 32 GB MacBook Pro (15-inch, 2018).</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-sh data-lang=sh>$ use-java10
<span class=nv>JAVA_HOME</span><span class=o>=</span>/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home
$ java -version
openjdk version <span class=s2>&#34;10.0.2&#34;</span> 2018-07-17
OpenJDK Runtime Environment 18.3 <span class=o>(</span>build 10.0.2+13<span class=o>)</span>
OpenJDK 64-Bit Server VM 18.3 <span class=o>(</span>build 10.0.2+13, mixed mode<span class=o>)</span>

$ use-java8
<span class=nv>JAVA_HOME</span><span class=o>=</span>/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home
$ java -version
openjdk version <span class=s2>&#34;1.8.0_181&#34;</span>
OpenJDK Runtime Environment <span class=o>(</span>Zulu 8.31.0.1-macosx<span class=o>)</span> <span class=o>(</span>build 1.8.0_181-b02<span class=o>)</span>
OpenJDK 64-Bit Server VM <span class=o>(</span>Zulu 8.31.0.1-macosx<span class=o>)</span> <span class=o>(</span>build 25.181-b02, mixed mode<span class=o>)</span>
</code></pre></td></tr></table></div></div><p>Results may depend on JVM versions and vendors.</p><h3 id=further-reading>Further Reading</h3><ul><li><a href=http://royvanrijn.com/blog/2018/05/java-and-docker-memory-limits>http://royvanrijn.com/blog/2018/05/java-and-docker-memory-limits</a></li><li><a href=https://blog.csanchez.org/2017/05/31/running-a-jvm-in-a-container-without-getting-killed/>https://blog.csanchez.org/2017/05/31/running-a-jvm-in-a-container-without-getting-killed/</a></li><li><a href=https://bugs.openjdk.java.net/browse/JDK-8186315>https://bugs.openjdk.java.net/browse/JDK-8186315</a></li><li><a href=https://bugs.openjdk.java.net/browse/JDK-8189497>https://bugs.openjdk.java.net/browse/JDK-8189497</a></li><li><a href=https://docs.openshift.com/container-platform/3.9/dev_guide/application_memory_sizing.html>https://docs.openshift.com/container-platform/3.9/dev_guide/application_memory_sizing.html</a></li><li><a href=https://jaxenter.com/better-containerized-jvms-jdk-10-140593.html>https://jaxenter.com/better-containerized-jvms-jdk-10-140593.html</a></li><li><a href=https://jaxenter.com/nobody-puts-java-container-139373.html>https://jaxenter.com/nobody-puts-java-container-139373.html</a></li><li><a href=https://stackoverflow.com/questions/39717077/how-do-i-start-a-jvm-with-unlimited-memory>https://stackoverflow.com/questions/39717077/how-do-i-start-a-jvm-with-unlimited-memory</a></li><li><a href=https://stackoverflow.com/questions/49854237/is-xxmaxramfraction-1-safe-for-production-in-a-containered-environment/50261206#50261206>https://stackoverflow.com/questions/49854237/is-xxmaxramfraction-1-safe-for-production-in-a-containered-environment/50261206#50261206</a></li><li><a href="https://www.reddit.com/r/java/comments/8jkt6h/java_and_docker_the_limitations/?st=jh82hof9&sh=5f385f3d">https://www.reddit.com/r/java/comments/8jkt6h/java_and_docker_the_limitations/?st=jh82hof9&sh=5f385f3d</a></li></ul><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Please note that the MaxRAM value shows the maximum amount of memory possible for the given architecture (32/64 bit). <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>This changes for small RAM values. On my machine, the JVM uses MaxRAMFraction=2 if there is &lt;= 256 MB RAM and MaxRAMFraction=1 if there is &lt;= 8 MB RAM. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><a href=https://www.oracle.com/technetwork/java/hotspotfaq-138619.html#threads_oom>https://www.oracle.com/technetwork/java/hotspotfaq-138619.html#threads_oom</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p><a href=https://developers.redhat.com/blog/2017/04/04/openjdk-and-containers>https://developers.redhat.com/blog/2017/04/04/openjdk-and-containers</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p><a href=https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html>https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html</a> <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Cgroups>https://en.wikipedia.org/wiki/Cgroups</a> <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7 role=doc-endnote><p>Keep in mind that if you run Docker in a VM (e.g. on OS X) you will see the resources of your VM, not your physical machine. <a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8 role=doc-endnote><p><a href=https://blogs.oracle.com/java-platform-group/java-se-support-for-docker-cpu-and-memory-limits>https://blogs.oracle.com/java-platform-group/java-se-support-for-docker-cpu-and-memory-limits</a> <a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9 role=doc-endnote><p><a href=https://www.oracle.com/technetwork/java/javase/8u131-relnotes-3565278.html>https://www.oracle.com/technetwork/java/javase/8u131-relnotes-3565278.html</a> <a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10 role=doc-endnote><p><a href=https://github.com/atamanroman/portfolio/tree/master/static/articles/jvm-memory-settings-container-environment/loadtest>https://github.com/atamanroman/portfolio/tree/master/static/articles/jvm-memory-settings-container-environment/loadtest</a> <a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11 role=doc-endnote><p>removed in Java 11 <a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:12 role=doc-endnote><p>enabled per default on servers, Linux only <a href=#fnref:12 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:13 role=doc-endnote><p>Java 10 deprecates all <code>-XX:{Initial|Min|Max}RAMFraction</code> flags and introduced the corresponding <code>-XX:{Initial|Min|Max}RAMPercentage</code> flags. <a href=#fnref:13 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/links/change-git-user-depending-current-directory-conditional-include/>Change Your Git User Depending on the Current Directory with Conditional Includes</a></li><li><a href=/articles/usecontainersupport-to-the-rescue/>+UseContainerSupport to the Rescue</a></li><li><a href=/articles/jvm-memory-settings-container-environment/>JVM Memory Settings in a Container Environment</a></li></ul></div></div></aside><footer><p>&copy; 2021 <a href=https://www.atamanroman.dev/><b>@atamanroman - My Personal Space - IT, Development, Software Architecture and Things I Care About</b></a>
· <a href=https://github.com/atamanroman><b>GitHub</b></a>
· <a href=https://twitter.com/atamanroman><b>Twitter</b></a>
· <a href=https://www.linkedin.com/in/atamanroman><b>LinkedIn</b></a>
· <a href=https://www.xing.com/profile/Roman_Ataman><b>XING</b></a>
· <a href=https://stackoverflow.com/users/366299/atamanroman><b>StackOverflow</b></a>
· <a href=https://medium.com/@atamanroman><b>Medium</b></a></p></footer></body></html>